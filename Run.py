from ILP.load_balancing_steiner_tree import LoadBalancingSteinerTreefrom ILP.Graph_generator import GraphGeneratorGrid2Dfrom DQN.Grid2D_dqn_train import Deeplearningfrom Heuristic.k_shortest_path import k_shortest_pathsfrom Request_Model.Request_Model import RequestGeneratorfrom mpl_toolkits.axes_grid1.inset_locator import inset_axesfrom matplotlib.patches import ConnectionPatchimport matplotlib.pyplot as pltimport networkx as nxfrom tqdm import tqdmimport numpy as npimport randomimport timeGraph_m = 5Graph_n = Graph_mNum_requests = 1000percentage = 1Network_pth = 2000Train_episodes = 50001Test_total = 200train_episodes = 0str_time = time.strftime("%y""%m""%d""%S")w = 20h = 24axes_t =(0.3, 0.15, 0.8, 0.7)axes_w =(0.3, 0.3, 1.2, 1.2)def generate_requests(graph_model,reques_model,i):    graph_model.src_node = reques_model[i].src_node    graph_model.dst_node = reques_model[i].dst_node    graph_model.dst_list = [graph_model.dst_node]    graph_model.steiner_nodes = [graph_model.src_node,graph_model.dst_node]def ILP_solution(model):                 ## 1.ILP    ILP_path = []    weight_ILP = 0    cost, res,time = LoadBalancingSteinerTree(model, 5).main(plot=False)    for i in res:        weight_ILP += model.int_link_dict[i].weight        if model.int_link_dict[i].node_1 not in ILP_path:            ILP_path.append(model.int_link_dict[i].node_1)        if model.int_link_dict[i].node_2 not in ILP_path:            ILP_path.append(model.int_link_dict[i].node_2)    # print("ILP:", ILP_path, '\n', "ILP_time:", "cost:",cost, "time:", time, '\n')    return ILP_path,weight_ILP,time,resdef Dijkstra_solution(model):            ## 2.Dijkstra    weight_GIJ = 0    Dj_pre = time.time()    p = nx.shortest_path(model.G, model.src_node, model.dst_node, weight='weight')    Dj_after = time.time()-Dj_pre    for i in range(len(p)-1):        weight_GIJ += model.n1n2_link_dict[(p[i],p[i+1])].weight    # print("Dijkstra:", p, '\n', "time:", Dj_after - Dj_pre)    return p,weight_GIJ,Dj_afterdef KSP_solution(model):           ## 3.Heuristic    weight_Heu =0    Heuristic_pre = time.time()    length, path = k_shortest_paths(model.G_contrast_Inverse, model.src_node, model.dst_node,  3)    Heuristic_after = time.time()-Heuristic_pre    p =path[0]    for i in range(len(p)-1):        weight_Heu += model.n1n2_link_dict[(p[i],p[i+1])].weight    # print("Heuristic:", path, '\n', "cost:",length, "time:", Heuristic_after - Heuristic_pre)    return p,weight_Heu,Heuristic_afterdef DQN_solution(graph_model,net_path):    """ Load graph model and Training """    weight_DQN = 0    DQN_path, ILP_path, reward,_t = DQN_model.take_action(graph_model,plot=False, net_path=net_path)    for i in range(len(DQN_path) - 1):        try:            weight_DQN += graph_model.n1n2_link_dict[DQN_path[i], DQN_path[i + 1]].weight        except KeyError:            weight_DQN += 200    return DQN_path,weight_DQN, _tdef zone_and_linked(ax, axins, zone_left, zone_right, x, y, linked,                    x_ratio=0.02, y_ratio=0.02):    """缩放内嵌图形，并且进行连线    ax:         调用plt.subplots返回的画布。例如： fig,ax = plt.subplots(1,1)    axins:      内嵌图的画布。 例如 axins = ax.inset_axes((0.4,0.1,0.4,0.3))    zone_left:  要放大区域的横坐标左端点    zone_right: 要放大区域的横坐标右端点    x:          X轴标签    y:          列表，所有y值    linked:     进行连线的位置，{'bottom','top','left','right'}    x_ratio:    X轴缩放比例    y_ratio:    Y轴缩放比例    """    xlim_left = x[zone_left] - (x[zone_right] - x[zone_left]) * x_ratio    xlim_right = x[zone_right] + (x[zone_right] - x[zone_left]) * x_ratio    y_data = np.hstack([yi[zone_left:zone_right] for yi in y])    ylim_bottom = np.min(y_data) - (np.max(y_data) - np.min(y_data)) * y_ratio    ylim_top = np.max(y_data) + (np.max(y_data) - np.min(y_data)) * y_ratio    axins.set_xlim(xlim_left, xlim_right)    axins.set_ylim(ylim_bottom, ylim_top)    ax.plot([xlim_left, xlim_right, xlim_right, xlim_left, xlim_left],            [ylim_bottom, ylim_bottom, ylim_top, ylim_top, ylim_bottom], "black")    if linked == 'bottom':        xyA_1, xyB_1 = (xlim_left, ylim_top), (xlim_left, ylim_bottom)        xyA_2, xyB_2 = (xlim_right, ylim_top), (xlim_right, ylim_bottom)    elif linked == 'top':        xyA_1, xyB_1 = (xlim_left, ylim_bottom), (xlim_left, ylim_top)        xyA_2, xyB_2 = (xlim_right, ylim_bottom), (xlim_right, ylim_top)    elif linked == 'left':        xyA_1, xyB_1 = (xlim_right, ylim_top), (xlim_left, ylim_top)        xyA_2, xyB_2 = (xlim_right, ylim_bottom), (xlim_left, ylim_bottom)    elif linked == 'right':        xyA_1, xyB_1 = (xlim_left, ylim_top), (xlim_right, ylim_top)        xyA_2, xyB_2 = (xlim_left, ylim_bottom), (xlim_right, ylim_bottom)    con = ConnectionPatch(xyA=xyA_1, xyB=xyB_1, coordsA="data",                          coordsB="data", axesA=axins, axesB=ax)    axins.add_artist(con)    con = ConnectionPatch(xyA=xyA_2, xyB=xyB_2, coordsA="data",                          coordsB="data", axesA=axins, axesB=ax)    axins.add_artist(con)def plot_svg(x,y,w,h,axes,y_name,file_name,signal):    fig, ax = plt.subplots(1, 1)    ax.plot(x, y[0], label='KSP', alpha=0.7, marker='o', markersize=5)    ax.plot(x, y[1], label='DQN-LFR', alpha=0.7, marker='v', markersize=5)    ax.plot(x, y[2], label='ILP', alpha=0.7, marker='x', markersize=5)    ax.legend(loc='best',fontsize=14)    ax.set_xlabel(xlabel='Episode/k',fontsize=15)    ax.set_ylabel(ylabel=y_name,fontsize=15)    plt.rcParams['font.sans-serif'] = ['SimHei']    plt.tick_params(labelsize=13)    axins = inset_axes(ax, width="40%", height="30%", loc='lower left',                       bbox_to_anchor=axes,                       bbox_transform=ax.transAxes)  # （x0,y0,width,height）    axins.plot(x, y[0], label='KSP', alpha=0.7, marker='o', markersize=5)    axins.plot(x, y[1], label='DQN-LFR', alpha=0.7, marker='v', markersize=5)    if signal:        axins.plot(x, y[2], label='ILP', alpha=0.7, marker='x', markersize=5)        zone_and_linked(ax, axins, w, h, x, y[:3], 'top')    else:        zone_and_linked(ax, axins, w, h, x, y[:2], 'top')    fig.savefig(file_name, dpi=1200)    plt.close()def generate_graph_and_request_model(num_requests, request_name):    """generate graph model and request model"""''    Model = GraphGeneratorGrid2D(Graph_m, Graph_n, percentage)      # Graph Model    Requests = RequestGenerator(Model.G)    request_model = Requests.generate_requests(num_requests, 0, 0)  # Request Model    Model.save_graph_model()    Model.draw_and_save("Graph.png")    Requests.save_request_model(request_model, Model.directory, request_name)def run(graph_model,request_model,dqn_model,net_path,Train=False,Test_one=False,Test=False):    if Train:        dqn_model.train(Network_pth, Train_episodes, graph_model)    if Test_one:        k =  random.randint(0,1000)        generate_requests(graph_model,request_model,k)        print(graph_model.src_node,graph_model.dst_node)        p1, w1, t1,res = ILP_solution(graph_model)        # load balancing  beta*(max-min)        # p2, w2, t2 = Dijkstra_solution(graph_model)     # shortest path with weight        p3, w3, t3 = KSP_solution(graph_model)            # LB_1 = a*W+b*(k/B)        p4, w4, t4 = DQN_solution(graph_model,net_path)        graph_model.draw_and_save_load_balancing_steiner_tree(res,graph_model.directory+'ILP.svg')        dqn_model.plot_path(graph_model.directory,p3, 'KSP.svg')        dqn_model.plot_path(graph_model.directory,p4, 'DQN-LFR.svg')        graph_model.draw_and_save_load_balancing_steiner_tree(res,graph_model.directory+'ILP.pdf')        dqn_model.plot_path(graph_model.directory,p3, 'KSP.pdf')        dqn_model.plot_path(graph_model.directory,p4, 'DQN-LFR.pdf')        print('w1:',w1,'w3:',w3,'w4:',w4)    if Test:        right_list_ILP, time_list_ILP = [], []        right_list_Heu, time_list_Heu = [], []        right_list_DQN, time_list_DQN = [], []        weight_list_ILP, weight_list_Dij, weight_list_Heu, weight_list_DQN = [],[],[],[]        Train_list = []        for train_episodes in tqdm(range(Network_pth, Train_episodes, Network_pth)):            net_path = 'DQN/Graph_and_Net_Model/model/23031130_55/percent_1/policy_net-' + str(train_episodes) + '.pth'            Train_list.append(train_episodes/1000)            t_1 = t_2 = t_3 = t_4 = 0            w_1 = w_2 = w_3 = w_4 = 0            count_Heu = count_DQN = count_DQN_Heu = 0            for i in range(Test_total):                generate_requests(graph_model,request_model,i)                p1,w1,t1,res = ILP_solution(graph_model)      # load balancing  beta*(max-min)                p2,w2,t2 = Dijkstra_solution(graph_model)                p3,w3,t3 = KSP_solution(graph_model)          # LB_1 = a*W+b*(k/B)                p4,w4,t4 = DQN_solution(graph_model,net_path=net_path)                p1.sort()                p2.sort()                p3.sort()                p4.sort()                if p1 == p3:                    count_Heu += 1                if p1 == p4:                    count_DQN += 1                if p3 == p4:                    count_DQN_Heu += 1                t_1 += t1                t_2 += t2                t_3 += t3                t_4 += t4                w_1 += w1                w_2 += w2                w_3 += w3                w_4 += w4            weight_list_ILP.append(round(w_1/Test_total,2))            # weight_list_Dij.append(round(w_2/Test_total,2))            weight_list_Heu.append(round(w_3/Test_total,2))            weight_list_DQN.append(round(w_4/Test_total,2))            right_list_Heu.append(100*round(count_Heu / Test_total, 2))            right_list_DQN.append(100*round(count_DQN / Test_total, 2))            time_list_ILP.append(1000*round(t_1,2))            time_list_Heu.append(1000*round(t_3,2))            time_list_DQN.append(1000*round(t_4,2))        y_t = [time_list_Heu,time_list_DQN,time_list_ILP]        y_w = [weight_list_Heu,weight_list_DQN,weight_list_ILP]        plot_svg(Train_list, y_t, w, h, axes_t,'Computation time/ms', "Time.svg", 0)        plot_svg(Train_list, y_t, w, h, axes_t,'Computation time/ms', "Time.pdf", 0)        plot_svg(Train_list, y_w, w, h, axes_w,'Average path  cost (UC)', "weight.svg", 1)        plot_svg(Train_list, y_w, w, h, axes_w,'Average path  cost (UC)', "weight.pdf", 1)        plt.rcParams['font.sans-serif'] = ['SimHei']  # 显示汉字        plt.tick_params(labelsize=13)        plt.xlabel('Episode/k',fontsize=15)  # x轴标题 bandwidth        plt.ylabel('Empirical accuracy/%',fontsize=15)  # y轴标题 LB        plt.ylim(0, 100)        plt.plot(Train_list, right_list_Heu, marker='o', markersize=4)  # 绘制折线图，添加数据点，设置点的大小        plt.plot(Train_list, right_list_DQN, marker='v', markersize=4)        plt.legend(['KSP', 'DQN-LFR'],fontsize=14)  # 设置折线名称        plt.savefig("Right_Rate.svg", dpi=1200)        plt.savefig("Right_Rate.pdf", dpi=1200)        plt.close()if __name__ == '__main__':    net_path = 'DQN/Graph_and_Net_Model/model/23031130_55/percent_1/policy_net-45000.pth'    directory = 'DQN/Graph_and_Net_Model/model/23031130_55/'    graph_name = 'graph_model.pkl'    request_name = 'request_model_1000.pkl'    graph_path = directory + graph_name    request_path = directory + request_name    """Generator the Grapl Model and Request Model"""    # generate_graph_and_request_model(Num_requests,request_name)    """ run the expermen t"""    Graph_model = GraphGeneratorGrid2D(Graph_m, Graph_n, percentage).load_graph_model(graph_path)    DQN_model = Deeplearning(Graph_model)    Request = RequestGenerator(Graph_model.G)    Request_Model = Request.load_request_model(request_path)    run(Graph_model, Request_Model, DQN_model, net_path, Train=True)    # run(Graph_model,Request_Model,DQN_model,net_path,Test_one=True)    # run(Graph_model, Request_Model, DQN_model, net_path, Test=True)